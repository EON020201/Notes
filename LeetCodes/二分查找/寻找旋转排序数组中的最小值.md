# 153. 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

## 做法

判断nums[mid]是在最小值的左侧还是右侧，可以和最后一个数比大小，由于最小值一定在数组中，那么最后一个数要么是最小值，要么在最小值右侧(所以n-1是蓝色)，所以可以在0到n-2中二分。

如果 nums[mid] 小于最后一个数，那么 nums[mid] 有两种情况，它在一段递增数组中，或者在两段递增数组中的第二段，无论是哪种情况，nums[mid] 要么是最小值，要么在最小值右侧，这种情况下，将其染成蓝色，否则由于我们在0到n-2中二分，是不可能等于最后一个数的；那么另外一种情况就是 nums[mid] 大于最后一个数，那么 nums[mid] 就不可能在只有一段递增的情况中了，说明 nums[mid] 一定在最小值左侧，这种情况染成红色。